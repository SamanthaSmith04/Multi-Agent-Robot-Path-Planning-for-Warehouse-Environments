%{
    RRT Planner
    Parameters:
        start_pos: The (x,y) position of the initial position of the robot
        goal_pos:  The (x,y) position of the goal position of the robot
        map:       The array that contains the loaded csv file 
                   for the environment
        scale:     The scale for a single grid point in the map
    Returns:
        plan:      The path plan generated by the RRT algorithm. 
                   Order of points: start -> goal
%}

function plan = RRT(start_pos, goal_pos, map, scale)
    %% rrt config parameters
    bias = 1;
    max_dist = scale;
    max_tree = 2000;
    goal_threshold = scale;

    %% set up bounds for planning
    x_min = 0;
    y_min = 0; 
    map_dims = size(map);
    x_max = (map_dims(2)) * scale;
    y_max = (map_dims(1)) * scale;
    
    %% initialize the tree
    nodes(1).x = start_pos(1);
    nodes(1).y = start_pos(2);
    nodes(1).cost = 0;
    nodes(1).parent = 0;


    %% plot the initial RRT plan graph
    figure(1); hold on; grid on
    
    axis equal
    axis([x_min,x_max,y_min,y_max]);
    % plot the boundary
    plot([x_min, x_min, x_max, x_max, x_min],[y_min, y_max, y_max, y_min, y_min], 'k--', 'LineWidth', 1); 
    drawnow;
    % plot the starting point
    plot(start_pos(1), start_pos(2), 'ko', 'MarkerSize',3, 'MarkerFaceColor','k');
    drawnow;
    % plot the goal point and goal region
    plot(goal_pos(1), goal_pos(2), 'go', 'MarkerSize',3, 'MarkerFaceColor','g');
    drawnow;
    th = 0:pi/50:2*pi;
    xcircle = goal_threshold * cos(th) + goal_pos(1);
    ycircle = goal_threshold * sin(th) + goal_pos(2);
    h = plot(xcircle, ycircle);
    drawnow;
    % Plot the obstacles
    for i = 1:map_dims(1) %rows
        for j = 1:map_dims(2) %cols
            if map(i, j) == 1
                rectangle('Position', [(j-1)*scale, (map_dims(1)-i)*scale, scale, scale], 'FaceColor', 'r', 'EdgeColor', 'none');
                drawnow;
            end
        end
    end

    %% Plan
    iter = 2;

    while iter < max_tree
        x_rand = (x_max-x_min)*rand^bias;
        y_rand = (y_max-y_min)*rand^bias;

        p_index = sort_tree(nodes, x_rand, y_rand);
        x_near = nodes(p_index).x;
        y_near = nodes(p_index).y;

        [x_new, y_new] = local_planner(x_near, y_near, x_rand, y_rand, max_dist);

        c_test = collision_detector(x_near, y_near, x_new, y_new, map, scale);

        if c_test
            continue;
        end
        nodes(iter).x = x_new;
        nodes(iter).y = y_new;
        nodes(iter).parent = p_index;
        nodes(iter).cost = distance(x_new, y_new, x_near, y_near) + nodes(p_index).cost;
        plot([nodes(iter).x; nodes(p_index).x],[nodes(iter).y; nodes(p_index).y], 'b');
        pause(0.001);
        
        if distance(x_new, y_new, goal_pos(1), goal_pos(2)) <= goal_threshold
            break
        end
    
        iter = iter + 1;

    end

    %% final cost
    cost = nodes(end).cost;
    
    %% build final tree
    if iter < max_tree
        xPath(1) = goal_pos(1);
        yPath(1) = goal_pos(2);
        xPath(2) = nodes(end).x;
        yPath(2) = nodes(end).y;
        
        parent = nodes(end).parent;
        j=0;
        index = 1;
        while 1
            xPath(j+3) = nodes(parent).x;
            yPath(j+3) = nodes(parent).y;   
            plan(index).x = nodes(parent).x;
            plan(index).y = nodes(parent).y;
            parent = nodes(parent).parent;
            if parent == 0
                break
            end
            j=j+1;
            index = index + 1;
        end
        plot(xPath, yPath, 'g', 'Linewidth', 3);
        else
            disp('No path found. Increase number of iterations and retry.');
            return;
    end

    plan = flip(plan);

end
